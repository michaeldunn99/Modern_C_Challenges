#include "queue.h"

/**
 * Enqueues a vertex into the breadth-first search queue.
 *
 * @param vertex The vertex to enqueue.
 * @param explor_forest The exploration forest (Forest of spanning trees generated by breadth-first search on each connected component of the graph)
 * @param current_spanning_tree The current spanning tree being built (i.e. based on the connected component of the current source vertex).
 * @param curr_queue The breadth-first search queue.
 */
void enqueue(size_t vertex, exploration_forest* explor_forest, spanning_tree* current_spanning_tree, breadth_queue* curr_queue) {

    //Set the new end of the queue (circular queue implementation)
    size_t new_end = ((curr_queue->queue_end)+1) % GRAPH_SIZE;

    //If the new end of the queue is the same as the start of the queue, then the queue is full so we cannot add another item - this is an error
    if (new_end == curr_queue->queue_start) {
        printf("Error: Queue is full - cannot add another item\n");
        exit(-1);
    }

    //Add the vertex to the queue
    curr_queue->queue[curr_queue->queue_end] = vertex;

    //The vertex is now grey
    (explor_forest->colours)[vertex] = 'g';

    //The vertex is now part of the current spanning tree and the distance from the source vertex is updated according to the current layer of the search
    (current_spanning_tree->vertex_distances)[vertex] = (curr_queue->current_layer)+1;
    
    //Update the position of the end of the queue
    curr_queue->queue_end = new_end;
}

/**
 * Dequeues the first entry in the breadth-first search queue.
 *
 * @param explor_forest The exploration forest (Forest of spanning trees generated by breadth-first search on each connected component of the graph)
 * @param curr_queue The breadth-first search queue.
 */
void dequeue_first_entry(exploration_forest* explor_forest, breadth_queue* curr_queue) {
    //Set the new start of the queue (circular queue implementation)
    size_t new_start = ((curr_queue->queue_start)+1) % GRAPH_SIZE;

    //If the start of the queue is the same as the end of the queue, then the queue is empty so we cannot dequeue an item - this is an error
    if (curr_queue->queue_start == curr_queue->queue_end) {
        printf("Error: Queue is empty - cannot dequeue an empty queue\n");
        exit(-1);
    }

    //The item being dequeued now becomes black
    explor_forest->colours[curr_queue->queue[curr_queue->queue_start]] = 'b';

    //Add the vertex to the list of explored vertices (since we have now dequeued it from the queue and it is black, it is now considered explored)
    ++explor_forest->explored_vertices;

    //Update the value in the queue at the previous start position to be SIZE_MAX (i.e. the queue is now empty at this position)
    curr_queue->queue[curr_queue->queue_start] = SIZE_MAX;

    //Update the position of the start of the queue position
    curr_queue->queue_start = new_start;
}

/**
 * Initializes the breadth-first search queue.
 *
 * @param queue_init The queue to initialize.
 * @param source The source vertex to initialize the queue with.
 */

void initialize_queue(breadth_queue* queue_init, size_t source) {

    //Set the source vertex of the queue
    queue_init->queue_source_vertex = source;

    //Set the start of the queue to be position 0
    queue_init->queue_start = 0;

    //Set the end of the queue to be position 1
    queue_init->queue_end = 1;

    //Set the source vertex as the first item in the queue (i.e. in position 0 of the queue array)
    queue_init->queue[queue_init->queue_start] = source;

    //Set the iteration counter to 0
    queue_init->iteration_counter = 0;

    //Set the current layer of the search to be 0
    queue_init->current_layer = 0;

    //Set the number of vertices in the current layer to be 1 (since the source vertex is the only vertex in the first layer)
    (queue_init->layer_tracker)[0] = 1;
    for (int i = 1; i < GRAPH_SIZE; ++i) {
        //Set the number of vertices in every other layer to be 0 (since we have not yet explored any other vertices in the graph yet)
        (queue_init->layer_tracker)[i] = 0;
        if (i) {
            //Set the rest of the queue to be SIZE_MAX (i.e. the queue is currently empty at these positions)
            queue_init->queue[i] = SIZE_MAX;
        }
    } 
}